
## UIPaintingImageView

派生于UIimageView，输入一张UIimage，可产生模拟绘画的动画。

核心计算部分纯C++，只有渲染、流程控制、线程部分时使用OBJ-C，移植应该没什么问题。

下个版本计划，虽然时间不确定：

1. 核心计算部分单独抽出来独立文件。
2. 通过聚类方法，增强图片区域分割精度。


## 效果演示

[视频演示--打开bilibili](https://www.bilibili.com/video/av39187627/)

![1.gif](https://github.com/kaikai03/UIPaintingImageView/blob/master/PaintView/1.gif)

![2.gif](https://github.com/kaikai03/UIPaintingImageView/blob/master/PaintView/2.gif)

![3.gif](https://github.com/kaikai03/UIPaintingImageView/blob/master/PaintView/3.gif)


## 主要文件

主要控件对象为UIPaintingImageView ，其他文件只是为了demo演示。

    以下为重要文件，其他都无关紧要。
    PaintView
    |--UIPaintingImageView.h
    |--UIPaintingImageView.mm
    |--source.bundle 
        |--haarcascade_frontalface_alt2.xml //脸部识别的预设文件
        |--mask1.jpg  //绘图时的笔刷效果掩板
        |--mask2.jpg  //绘图时的笔刷效果掩板
        |--mask3.jpg  //绘图时的笔刷效果掩板

## 使用方法

安装OpenCV
    
    pod 'OpenCV'
    pod install

本控件最重要的是prepareForPainting方法，用于初始化后控件设置必要参数。

    /**
    prepareForPainting  -public
    本对象初始化后必须执行的方法。用于设置各种参数以及初始化绘图上下文。

    @param img 需要进行painting的原图
    @param fps 绘制过程每秒帧数参考值，并不严格准守。
    @param sketchTimeMulti 线稿绘制过程时长倍率参考值，并不严格准守。当设置为0时，该绘图步骤跳过。
    @param groundingTimeMulti 背景上色过程时长倍率参考值，并不严格准守。当设置为0时，该绘图步骤跳过。
    @param lineTimeMulti 补线绘制过程时长倍率参考值，并不严格准守。当设置为0时，该绘图步骤跳过。
    @param originTimeMulti 原图覆盖绘制过程时长倍率参考值，并不严格准守。当设置为0时，该绘图步骤跳过。
    @return
    */
    -(void)prepareForPainting:(UIImage*)img fps:(uint)fps sketchTimeMulti:(float)stm groundingTimeMulti:(float)gtm lineTimeMulti:(float)ltm originTimeMulti:(float)otm
    
其余重要函数
    
    //需要实现的实现代理方法
    -(void)drawEnding;
    //开始生成动画并展示。
    -(void)startDrawing;

其他设置，参照头文件中宏定义。


最后，建议本控件初始化过程请在主线程中实现。

因为初始化过程中，使用了系统绘图上下文来重采样图片。所以在子线程中来初始化本控件有可能会出现与软件其他与图形上下文相关的行为冲突，带来错误。


--------

## 过程描述

简单描述一下整体过程，细节计算就不说了，等有必要的时候在写（看心情）。相信通过关键字就知道怎么干的了，没必要浪费唇舌。

#### 初值准备

重新采样原图，避免原图太大招成过分低效。
图像灰度、高斯作为后续使用素材避免重复采样。


#### 区分绘画区块

1. haar取头位置及大小。
2. 二值化+降噪+突出主题（高亮度部分，相对较高，过爆区低权重）做预处理。形成一些“区域”。
3. 计算图像中的所有边界，然后利用随机膨胀来形成一些封闭区域。这一步与第二步并行。
4. 对（2）、（3）得到“区域”利用相关性系数法判断各之间的关系，合并。然后分水岭算法分区。
5. 最后建立包边，得到多边形包块列表。

#### 笔触顺序

计算每块面积。

各区块按头位置以及区块面积大小确定排序顺序。

头所在区或最大面积区，向两边延伸，如果当前附近有小区块则优先考虑。接着由第二大面积区开始，向周围延伸。以此类推。

根据区块排列顺序，重新采样canny的边界点。

采样使用扫描线，从左往右，从上往下，  扫到的第一个点，取值后，点去除。然后开始递归，检查四向连通（左下，下，右下，右），优先完成一条最长的完整线。然后直到该点连接的全部线全部获取。不过为了避免一条线来来回回太长，取大约几百像素就中断了。（当然还为了避免爆栈）

至此，基本笔触顺序获取完成。

不过后来进一步优化，因为有时候有些包块会很大，例如背景蓝天。此时如果画面上Y方向的长物体少的话，按照上述方法采样画出来的顺序像是打印机。于是把块度太宽或太长的区块分为几个部分分别采样，而不是直接横穿整个屏幕。

#### 绘制草图

绘制素描线条时，并不使用canny的结果，因为太“干”。

通过低强度高斯平滑取反，与高强度高斯做差，得到高斯平滑掉的突变，以此得到一张类似低密度阴影图。加上sobel或者拉普拉斯作为边界强化，就得到一张完整的铅笔“草图”。

利用上一节获取到的笔触顺序，将草图绘制在图形上下文空间中，按照“帧率”和预设绘图时间渲染图像。

#### 绘制底色

按照笔触的分块顺序，对草图进行上色。

第一遍，按照区块抠原图，抠出的部分直接取均值，然后再与255平均，作为纯底色进行上色。

第二遍，对整图使用最大强度的stylization进行风格化，然后用各区块进行抠图，分别与各自底色加权平均。

第三遍，在第二遍的基础上加权平均一次，产生水彩效果。

为了上色看起来不那么单调，对大块的区域模仿手工刷油漆效果先涂一遍，再以斜对角扫描线的形式补全毛刷没刷到的位置。

#### 加强线条与阴影
作为水彩到原图的过度过程，我们知道水彩风格从整体上看，色彩是偏淡的。而现实照片是邻角分明，通过阴影来表现立体感。

所以在图像绘制原图前，把“重色彩”部分，用黑色先“打底”。这步用拉普拉斯的粗略边界和阴影效果来覆盖，理论上有比较好的效果，但由于拉普拉斯本身的问题，效果不稳定。我最后直接用canny描个边就拉倒了（偷懒）。

#### 绘制原图

进行两次涂抹，用模糊原图按区块顺序加权平均一次，让水彩效果产生立体感，接近原图。最后一次用原图覆盖。

至此，整个绘图过程完成。

#### 问题

因为基于信号波动来分区，基于高频高能信号来决定绘画顺序和笔触。

所以高强度的高斯处理过的图像是没法处理的，帕金森手拍出来的是没法处理的，还有那种柔光美颜开到最大的那些。

还有一个情况就是波光粼粼的水面，湿漉漉的高清草地，虽然能处理，但是需要处理的东西太多。高能信号太多，太零散，会导致性能消耗严重。

最后，效果最好的当然就是专业摄影师的作品或者是人工作画的作品：有意识地利用光能来强调“主题”，主次边界分明，主次对比强烈，主要细节清晰。






